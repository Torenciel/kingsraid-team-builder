<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>KingsRaid Team Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>
    <style>
      /* [Garder tous vos styles CSS existants] */
      body {
        background-color: #171717;
      }
      .team-title-container {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        margin-bottom: 16px;
      }
      .team-title-input {
        background: #262626;
        border: 1px solid #525252;
        border-radius: 4px;
        padding: 4px 8px;
        color: white;
        text-align: center;
        font-size: 18px;
        font-weight: 600;
        width: 300px;
      }
      .team-title-input:focus {
        outline: none;
        border-color: #3b82f6;
      }
      .edit-title-btn {
        background: #3b82f6;
        border: none;
        border-radius: 4px;
        padding: 4px 8px;
        color: white;
        cursor: pointer;
        font-size: 12px;
      }
      .edit-title-btn:hover {
        background: #2563eb;
      }
      .character-slot {
        background: #262626;
        border: 1px solid #525252;
        position: relative;
      }
      .character-slot.empty:hover {
        background: #404040;
      }
      .hero-card {
        background: #1f2937;
        position: relative;
        aspect-ratio: 1;
      }
      .hero-card.in-team {
        border: 4px solid #fbbf24;
        box-shadow: 0 0 10px #fbbe2488;
      }
      .hero-card:hover {
        scale: 1.05;
      }
      .hero-name {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(
          to top,
          rgba(0, 0, 0, 0.9),
          rgba(0, 0, 0, 0.4),
          transparent
        );
        color: white;
        padding: 4px 2px;
        font-size: 12px;
        font-weight: 600;
        text-align: center;
        height: 60px;
        display: flex;
        align-items: flex-end;
        justify-content: center;
      }
      .hero-image {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .class-icon {
        position: absolute;
        top: 2px;
        left: 2px;
        width: 20px;
        height: 20px;
        background-color: #433c30;
        border-radius: 100%;
      }
      .class-icon.missing {
        display: none;
      }
      .remove-btn {
        position: absolute;
        top: -8px;
        right: -8px;
        background: #ef4444;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        border: 2px solid #404040;
        z-index: 10;
        padding: 0;
      }
      .character-slot:not(.empty):hover .remove-btn {
        display: flex;
      }
      .sub-slot {
        background: #262626;
        border: 1px solid #525252;
        border-radius: 4px;
        position: relative;
      }
      .sub-slot.empty:hover {
        background: #404040;
      }
      .sub-slot-image {
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 4px;
      }
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        align-items: center;
        justify-content: center;
      }
      .modal-content {
        background: #171717;
        padding: 20px;
        border-radius: 8px;
        max-width: 500px;
        width: auto;
        max-height: 90vh;
        overflow-y: auto;
      }
      .ut-option,
      .uw-option,
      .artifact-option {
        width: 80px;
        height: 80px;
        cursor: pointer;
        border-radius: 4px;
        background: #262626;
        border: 2px solid #525252;
      }
      .ut-option:hover,
      .uw-option:hover,
      .artifact-option:hover {
        border-color: #64e210;
      }
      .ut-option.selected,
      .uw-option.selected,
      .artifact-option.selected {
        border-color: #fbbf24;
      }
      .stars-container {
        display: flex;
        justify-content: center;
        gap: 8px;
        margin: 15px 0;
      }
      .star {
        font-size: 26px;
        cursor: pointer;
        color: #737373;
      }
      .star.filled {
        color: #fbbf24;
      }
      .star.hover-preview {
        color: #fbbf24;
        opacity: 0.6;
      }
      .stars-text {
        position: absolute;
        bottom: 0px;
        left: 0px;
        color: #fbbf24;
        font-size: 12px;
        font-weight: bold;
        background: rgba(0, 0, 0, 0.7);
        padding: 1px 3px;
        border-radius: 3px;
      }
      .team-hero-name {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(
          to top,
          rgba(0, 0, 0, 0.9),
          rgba(0, 0, 0, 0.4),
          transparent
        );
        color: white;
        padding: 4px 2px;
        font-size: 12px;
        font-weight: 600;
        text-align: center;
        height: 60px;
        display: flex;
        align-items: flex-end;
        justify-content: center;
      }
      #artifact-modal .modal-content {
        max-width: 800px !important;
        width: fit-content !important;
        height: auto !important;
        max-height: none !important;
        padding: 15px;
      }
      .artifact-grid {
        display: grid;
        grid-template-columns: repeat(10, 1fr);
        gap: 2px;
        max-height: none;
        overflow-y: visible;
        padding: 2px;
        border-radius: 6px;
      }
      .artifact-option {
        width: 48px;
        height: 48px;
        cursor: pointer;
        border-radius: 2px;
        background: #262626;
        border: 2px solid #525252;
        position: relative;
      }
      .artifact-option:hover {
        border-color: #64e210;
        transform: scale(1.05);
      }
      .artifact-option.selected {
        border-color: #fbbf24;
        transform: scale(1.05);
      }
      .artifact-search {
        background: #262626;
        border: 1px solid #525252;
        border-radius: 6px;
        padding: 8px 12px;
        color: white;
        width: 100%;
        margin-bottom: 12px;
      }
      .artifact-search:focus {
        outline: none;
        border-color: #3b82f6;
      }
      .perk-grid {
        display: flex;
        flex-direction: column;
        gap: 4px;
        padding: 8px;
        border-radius: 6px;
      }
      .perk-row {
        display: flex;
        gap: 4px;
        justify-content: flex-start;
      }
      .perk-option {
        width: 50px;
        height: 50px;
        cursor: pointer;
        border-radius: 4px;
        background: #262626;
        border: 2px solid #525252;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        color: #9ca3af;
        transition: all 0.2s;
      }
      .perk-option:hover {
        border-color: #64e210;
        transform: scale(1.05);
      }
      .perk-option.selected {
        border-color: #fbbf24;
        background: #fbbf24;
        color: #1f2937;
        transform: scale(1.05);
      }
      .perk-option.disabled {
        opacity: 0.5;
        cursor: not-allowed;
        border-color: #6b7280;
      }
      #perk-modal .modal-content {
        max-width: 400px !important;
        width: 90% !important;
      }
      .perk-points {
        background: #262626;
        border-radius: 6px;
        padding: 10px;
        margin-bottom: 12px;
        text-align: center;
        border: 1px solid #525252;
      }
      .perk-points.over-limit {
        background: #7f1d1d;
        border-color: #dc2626;
      }
      .perk-preview {
        display: flex;
        flex-direction: column;
        gap: 2px;
        margin-top: 8px;
        max-width: 250px;
      }
      .perk-preview-row {
        display: flex;
        gap: 2px;
        justify-content: flex-start;
      }
      .perk-preview-option {
        width: 18px;
        height: 18px;
        border-radius: 4px;
        background: #262626;
        border: 1px solid #525252;
      }
      .perk-preview-option.selected {
        background: #fbbf24;
        border-color: #fbbf24;
      }
      .perk-slot-active {
        background: #fbbf24 !important;
        color: #1f2937 !important;
        font-weight: bold;
      }
    </style>
  </head>
  <body class="text-white min-h-screen">
    <div class="container mx-auto px-4 py-8">
      <!-- Header -->
      <header class="text-center mb-8">
        <h1 class="text-2xl font-bold mb-2">KingsRaid Team Builder</h1>
      </header>

      <!-- Team Slots -->
      <div class="mb-8">
        <div class="team-title-container">
          <h2 id="team-title-display" class="text-lg font-semibold">
            Your Team
          </h2>
          <input
            type="text"
            id="team-title-input"
            class="team-title-input"
            style="display: none"
            maxlength="50"
          />
          <button id="edit-title-btn" class="edit-title-btn">Edit</button>
        </div>

        <!-- Tous les slots disponibles imm√©diatement -->
        <div class="flex justify-center gap-6 flex-wrap" id="team-slots">
          <!-- 8 emplacements au total -->
        </div>

        <!-- Compteur d'√©quipe -->
        <div class="text-center text-sm text-neutral-400 mt-4">
          Heroes: <span id="current-team-size">0</span>/<span id="max-team-size"
            >8</span
          >
        </div>

        <!-- Bouton de sauvegarde seulement -->
        <div class="text-center mt-6">
          <button
            id="save-team"
            class="bg-green-600 hover:bg-green-700 rounded px-4 py-2 rounded"
          >
            Save Team & Get Share Link
          </button>
        </div>
      </div>

      <!-- Input pour afficher le lien de la team -->
      <div class="text-center mt-4">
        <input
          type="text"
          id="team-link-display"
          readonly
          placeholder="Team link will appear here after saving..."
          class="w-full max-w-md bg-neutral-800 border border-neutral-600 rounded px-3 py-2 text-sm text-center text-gray-300"
        />
      </div>

      <!-- Available Heroes -->
      <div>
        <div class="flex justify-between items-center mb-4">
          <h2 class="text-lg font-semibold">Available Heroes</h2>
          <div class="flex gap-2">
            <select
              id="sort-filter"
              onchange="loadHeroes(this.value)"
              class="bg-neutral-800 border border-neutral-600 rounded px-3 py-1 text-sm"
            >
              <option value="name">Sort by Name</option>
              <option value="release">Sort by Release</option>
            </select>

            <select
              id="role-filter"
              class="bg-neutral-800 border border-neutral-600 rounded px-3 py-1 text-sm"
            >
              <option value="all">All Roles</option>
              <option value="Knight">Knight</option>
              <option value="Warrior">Warrior</option>
              <option value="Archer">Archer</option>
              <option value="Mechanic">Mechanic</option>
              <option value="Assassin">Assassin</option>
              <option value="Wizard">Wizard</option>
              <option value="Priest">Priest</option>
            </select>
            <input
              type="text"
              id="search-input"
              placeholder="Search..."
              class="bg-neutral-800 border border-neutral-600 rounded px-3 py-1 text-sm w-32"
            />
          </div>
        </div>

        <div
          id="heroes-grid"
          class="grid grid-cols-4 md:grid-cols-8 lg:grid-cols-10 xl:grid-cols-12 gap-2"
        >
          <!-- Heroes will be loaded here -->
        </div>
        <div
          id="hero-count"
          class="text-center text-neutral-400 text-sm mt-4"
        ></div>
      </div>
    </div>

    <!-- Modal pour confirmer la suppression d'un h√©ros -->
    <div id="remove-hero-modal" class="modal">
      <div class="modal-content">
        <h3 class="text-lg font-bold mb-4 text-center">Remove Hero</h3>
        <p class="text-center mb-6" id="remove-hero-message">
          Are you sure you want to remove this hero from the team?
        </p>
        <div class="flex justify-center gap-4">
          <button
            id="confirm-remove-hero"
            class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded"
          >
            Yes
          </button>
          <button
            id="cancel-remove-hero"
            class="bg-neutral-600 hover:bg-neutral-700 px-4 py-2 rounded"
          >
            No
          </button>
        </div>
      </div>
    </div>

    <!-- Modal pour choisir les images UW -->
    <div id="uw-modal" class="modal">
      <div class="modal-content">
        <h3 class="text-lg font-bold mb-4 text-center">UW</h3>
        <div class="flex justify-center gap-4 mb-4" id="uw-options">
          <!-- Les options UW seront ajout√©es ici dynamiquement -->
        </div>
        <div class="stars-container" id="uw-stars">
          <!-- Les √©toiles UW seront ajout√©es ici dynamiquement -->
        </div>
        <div class="flex justify-center gap-4 mt-6">
          <button
            id="confirm-uw"
            class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded"
          >
            Confirm
          </button>
          <button
            id="cancel-uw"
            class="bg-neutral-600 hover:bg-neutral-700 px-4 py-2 rounded"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Modal pour choisir les images UT -->
    <div id="ut-modal" class="modal">
      <div class="modal-content">
        <h3 class="text-lg font-bold mb-4 text-center">UT</h3>
        <div
          class="grid grid-cols-2 gap-4 justify-items-center mb-4"
          id="ut-options"
        >
          <!-- Les options UT seront ajout√©es ici dynamiquement -->
        </div>
        <div class="flex justify-center mb-4" id="ut-empty-option">
          <!-- L'option vide pour UT sera ajout√©e ici dynamiquement -->
        </div>
        <div class="stars-container" id="ut-stars">
          <!-- Les √©toiles UT seront ajout√©es ici dynamiquement -->
        </div>
        <div class="flex justify-center gap-4 mt-6">
          <button
            id="confirm-ut"
            class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded"
          >
            Confirm
          </button>
          <button
            id="cancel-ut"
            class="bg-neutral-600 hover:bg-neutral-700 px-4 py-2 rounded"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Modal pour choisir les artefacts -->
    <div id="artifact-modal" class="modal">
      <div class="modal-content">
        <h3 class="text-lg font-bold mb-4 text-center">Artifact</h3>

        <!-- Barre de recherche -->
        <input
          type="text"
          id="artifact-search"
          placeholder="Search artifacts..."
          class="artifact-search"
        />

        <!-- Grid des artefacts -->
        <div class="artifact-grid" id="artifact-options">
          <!-- Les options artefacts seront ajout√©es ici dynamiquement -->
        </div>

        <!-- Option vide -->
        <div class="flex justify-center mt-4" id="artifact-empty-option">
          <!-- L'option vide pour artefact sera ajout√©e ici dynamiquement -->
        </div>

        <!-- √âtoiles -->
        <div class="stars-container" id="artifact-stars">
          <!-- Les √©toiles artefact seront ajout√©es ici dynamiquement -->
        </div>

        <!-- Boutons -->
        <div class="flex justify-center gap-4 mt-6">
          <button
            id="confirm-artifact"
            class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded"
          >
            Confirm
          </button>
          <button
            id="cancel-artifact"
            class="bg-neutral-600 hover:bg-neutral-700 px-4 py-2 rounded"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <!-- Modal pour choisir les perks -->
    <div id="perk-modal" class="modal">
      <div class="modal-content">
        <h3 class="text-lg font-bold mb-4 text-center">Perks</h3>

        <!-- Compteur de points -->
        <div id="perk-points-display" class="perk-points">
          <div class="text-sm font-semibold">
            Points used: <span id="perk-points-used">0</span> / 95
          </div>
        </div>

        <!-- Grid des perks -->
        <div class="perk-grid" id="perk-options">
          <!-- Les perks seront ajout√©es ici dynamiquement -->
        </div>

        <!-- Boutons -->
        <div class="flex justify-center gap-4 mt-6">
          <button
            id="confirm-perk"
            class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded"
          >
            Confirm
          </button>
          <button
            id="cancel-perk"
            class="bg-neutral-600 hover:bg-neutral-700 px-4 py-2 rounded"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>

    <script>
      // CONFIGURATION SIMPLIFIEE
      const MAX_TEAM_SLOTS = 8;

      let currentTeamTitle = "Your Team";
      let currentTeam = Array(MAX_TEAM_SLOTS).fill(null);
      let allHeroes = [];
      let allArtifacts = [];
      let currentSubSlots = Array(MAX_TEAM_SLOTS)
        .fill(null)
        .map(() => Array(4).fill(null));
      let currentSubStars = Array(MAX_TEAM_SLOTS)
        .fill(null)
        .map(() => Array(4).fill(0));
      let currentModalData = null;
      let pendingRemoveHeroId = null;

      // Initialisation compl√®te
      document.addEventListener("DOMContentLoaded", function () {
        console.log("üöÄ DOM charg√© - Initialisation...");

        const appStartTime = performance.now();
        let heroesLoadTime, artifactsLoadTime, teamLoadTime;

        // Initialiser l'interface d'abord (synchrone)
        initializeTeamSlots();
        setupFilters();
        setupModals();
        setupSaveLoad();
        setupTeamTitle();

        // Fonction asynchrone pour le chargement s√©quentiel
        async function initializeApp() {
          try {
            // Charger les h√©ros en premier
            console.log("üîÑ Chargement des h√©ros...");
            const heroesStartTime = performance.now();
            await loadHeroes();
            heroesLoadTime = (performance.now() - heroesStartTime).toFixed(2);
            console.log(`‚úÖ H√©ros charg√©s en ${heroesLoadTime}ms`);

            // Puis charger les artefacts
            console.log("üîÑ Chargement des artefacts...");
            const artifactsStartTime = performance.now();
            await loadArtifacts();
            artifactsLoadTime = (
              performance.now() - artifactsStartTime
            ).toFixed(2);
            console.log(`‚úÖ Artefacts charg√©s en ${artifactsLoadTime}ms`);

            // Enfin charger l'√©quipe depuis l'URL
            console.log("üîÑ Chargement de l'√©quipe depuis l'URL...");
            const teamStartTime = performance.now();
            await loadTeamFromURL();
            teamLoadTime = (performance.now() - teamStartTime).toFixed(2);
            console.log(`‚úÖ √âquipe charg√©e en ${teamLoadTime}ms`);

            // Calculer et afficher le temps total
            const totalTime = (performance.now() - appStartTime).toFixed(2);

            console.log(`üéØ CHARGEMENT TERMIN√â en ${totalTime}ms`);
            console.log(`üìä D√©tails du timing :`);
            console.log(`   ‚Ä¢ H√©ros : ${heroesLoadTime}ms`);
            console.log(`   ‚Ä¢ Artefacts : ${artifactsLoadTime}ms`);
            console.log(`   ‚Ä¢ √âquipe : ${teamLoadTime}ms`);
            console.log(`   ‚Ä¢ Total : ${totalTime}ms`);

            // Statistiques finales
            const heroCount = currentTeam.filter(
              (hero) => hero !== null
            ).length;
            console.log(`üèÜ La page est maintenant utilisable !`);
          } catch (error) {
            const errorTime = (performance.now() - appStartTime).toFixed(2);
            console.error(`üí• ERREUR apr√®s ${errorTime}ms:`, error);
          }
        }

        // D√©marrer le chargement asynchrone
        initializeApp();

        // V√©rification des artefacts
        setTimeout(() => {
          if (allArtifacts.length === 0) {
            console.warn(
              "‚ö†Ô∏è Aucun artefact charg√© - v√©rifiez le chemin du fichier JSON"
            );
          }
        }, 2000);
      });

      async function loadArtifacts() {
        try {
          const response = await fetch(
            "/kingsraid-data/artifact_release_order.json"
          );

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          console.log("üìä Donn√©es artefacts re√ßues:", data);

          // Convertir l'objet en tableau de noms d'artefacts
          if (data && typeof data === "object") {
            allArtifacts = Object.keys(data);
            console.log(
              `‚úÖ ${allArtifacts.length} artefacts charg√©s:`,
              allArtifacts.slice(0, 5)
            );
          } else {
            allArtifacts = [];
            console.warn("‚ùå Format de donn√©es d'artefacts non reconnu");
          }

          // V√©rifier que les images existent
          await verifyArtifactImages();

          return allArtifacts; // Retourner pour await
        } catch (error) {
          console.error("‚ùå Error loading artifacts:", error);
          allArtifacts = [];
          throw error; // Propager l'erreur
        }
      }

      async function verifyArtifactImages() {
        const missingImages = [];

        // Utiliser Promise.all pour v√©rifier plusieurs images en parall√®le
        const verificationPromises = allArtifacts.map(async (artifactName) => {
          const imagePath = `/kingsraid-data/assets/artifacts/${artifactName}.png`;
          try {
            const response = await fetch(imagePath, { method: "HEAD" });
            if (!response.ok) {
              missingImages.push(artifactName);
            }
          } catch (error) {
            missingImages.push(artifactName);
          }
        });

        await Promise.all(verificationPromises);

        if (missingImages.length > 0) {
          console.warn(
            `‚ö†Ô∏è Images manquantes pour: ${missingImages.join(", ")}`
          );
        } else {
          console.log("‚úÖ Toutes les images d'artefacts sont disponibles");
        }
      }

      function initializeTeamSlots() {
        const teamSlots = document.getElementById("team-slots");
        teamSlots.innerHTML = "";

        // Cr√©er tous les slots avec sous-slots
        for (let i = 0; i < MAX_TEAM_SLOTS; i++) {
          const slotContainer = document.createElement("div");
          slotContainer.className = "flex flex-col items-center gap-2";

          // Slot principal (H√©ro)
          const mainSlot = document.createElement("div");
          mainSlot.className =
            "character-slot w-[100px] h-[100px] rounded flex items-center justify-center cursor-pointer empty";
          mainSlot.innerHTML = '<span class="text-gray-400 text-lg">+</span>';

          // Container pour les 4 sous-slots (2x2)
          const subSlotsContainer = document.createElement("div");
          subSlotsContainer.className = "grid grid-cols-2 gap-1";

          // Cr√©er 4 sous-slots / sub-slot : UW, Ut, Artifacts, Perks
          for (let j = 0; j < 4; j++) {
            const subSlot = document.createElement("div");
            subSlot.className =
              "sub-slot w-[48px] h-[48px] rounded flex items-center justify-center cursor-pointer empty";
            subSlot.innerHTML = '<span class="text-gray-400 text-xs">+</span>';
            subSlot.onclick = () => handleSubSlotClick(i, j);
            subSlotsContainer.appendChild(subSlot);
          }

          // Container pour la preview des perks
          const perkPreviewContainer = document.createElement("div");
          perkPreviewContainer.className = "perk-preview";
          perkPreviewContainer.id = `perk-preview-${i}`;

          slotContainer.appendChild(mainSlot);
          slotContainer.appendChild(subSlotsContainer);
          slotContainer.appendChild(perkPreviewContainer);
          teamSlots.appendChild(slotContainer);
        }

        updateTeamDisplay();
      }

      function setupModals() {
        // Modal de confirmation pour supprimer un h√©ros
        const removeHeroModal = document.getElementById("remove-hero-modal");
        const confirmRemoveHeroBtn = document.getElementById(
          "confirm-remove-hero"
        );
        const cancelRemoveHeroBtn =
          document.getElementById("cancel-remove-hero");

        confirmRemoveHeroBtn.addEventListener("click", confirmRemoveHero);
        cancelRemoveHeroBtn.addEventListener("click", () =>
          closeModal("remove-hero-modal")
        );

        removeHeroModal.addEventListener("click", (e) => {
          if (e.target === removeHeroModal) {
            closeModal("remove-hero-modal");
          }
        });

        // Modal UW
        const uwModal = document.getElementById("uw-modal");
        const confirmUwBtn = document.getElementById("confirm-uw");
        const cancelUwBtn = document.getElementById("cancel-uw");

        confirmUwBtn.addEventListener("click", confirmUWSelection);
        cancelUwBtn.addEventListener("click", () => closeModal("uw-modal"));

        uwModal.addEventListener("click", (e) => {
          if (e.target === uwModal) {
            closeModal("uw-modal");
          }
        });

        // Modal UT
        const utModal = document.getElementById("ut-modal");
        const confirmUtBtn = document.getElementById("confirm-ut");
        const cancelUtBtn = document.getElementById("cancel-ut");

        confirmUtBtn.addEventListener("click", confirmUTSelection);
        cancelUtBtn.addEventListener("click", () => closeModal("ut-modal"));

        utModal.addEventListener("click", (e) => {
          if (e.target === utModal) {
            closeModal("ut-modal");
          }
        });

        // Modal Artifact
        const artifactModal = document.getElementById("artifact-modal");
        const confirmArtifactBtn = document.getElementById("confirm-artifact");
        const cancelArtifactBtn = document.getElementById("cancel-artifact");

        confirmArtifactBtn.addEventListener("click", confirmArtifactSelection);
        cancelArtifactBtn.addEventListener("click", () =>
          closeModal("artifact-modal")
        );

        artifactModal.addEventListener("click", (e) => {
          if (e.target === artifactModal) {
            closeModal("artifact-modal");
          }
        });

        // Modal Perk
        const perkModal = document.getElementById("perk-modal");
        const confirmPerkBtn = document.getElementById("confirm-perk");
        const cancelPerkBtn = document.getElementById("cancel-perk");

        confirmPerkBtn.addEventListener("click", confirmPerkSelection);
        cancelPerkBtn.addEventListener("click", () => closeModal("perk-modal"));

        perkModal.addEventListener("click", (e) => {
          if (e.target === perkModal) {
            closeModal("perk-modal");
          }
        });
      }

      function setupSaveLoad() {
        const saveBtn = document.getElementById("save-team");
        saveBtn.addEventListener("click", saveTeamToLink);
      }

      // ========== FONCTIONS AVEC STOCKAGE SERVEUR ==========

      // Setup pour le titre d'√©quipe
      function setupTeamTitle() {
        const editTitleBtn = document.getElementById("edit-title-btn");
        const teamTitleInput = document.getElementById("team-title-input");
        const teamTitleDisplay = document.getElementById("team-title-display");

        editTitleBtn.addEventListener("click", () => {
          if (teamTitleInput.style.display === "none") {
            // Mode √©dition
            teamTitleInput.value = currentTeamTitle;
            teamTitleInput.style.display = "block";
            teamTitleDisplay.style.display = "none";
            editTitleBtn.textContent = "Save";
            teamTitleInput.focus();
          } else {
            // Sauvegarde
            const newTitle = teamTitleInput.value.trim() || "Your Team";
            currentTeamTitle = newTitle;
            teamTitleDisplay.textContent = newTitle;
            teamTitleInput.style.display = "none";
            teamTitleDisplay.style.display = "block";
            editTitleBtn.textContent = "Edit";
          }
        });

        teamTitleInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
            editTitleBtn.click();
          }
        });
      }

      async function saveTeamToLink() {
        // V√©rifier qu'il y a au moins un h√©ros dans l'√©quipe
        const heroCount = currentTeam.filter((hero) => hero !== null).length;
        if (heroCount === 0) {
          alert("Please add at least one hero to your team before saving!");
          return;
        }

        // Afficher un indicateur de chargement
        const saveBtn = document.getElementById("save-team");
        const originalText = saveBtn.textContent;
        saveBtn.textContent = "Saving...";
        saveBtn.disabled = true;

        try {
          // Pr√©parer les donn√©es optimis√©es
          const teamData = {
            // Titre
            t: currentTeamTitle,

            // H√©ros : seulement les IDs
            h: currentTeam.map((hero) => (hero ? hero.id : null)),

            // Sous-slots optimis√©s
            s: currentSubSlots.map((slot) =>
              slot.map((item) => {
                if (!item) return null;

                if (item.includes("/uw.png")) return "uw";

                if (item.includes("/ut/")) {
                  const utNum = item.match(/ut\/(\d)\.png/)[1];
                  return `ut${utNum}`;
                }

                if (item.includes("/artifacts/")) {
                  const artifactName = item
                    .split("/artifacts/")[1]
                    .replace(".png", "");
                  return artifactName;
                }

                if (Array.isArray(item)) {
                  return item.join(",");
                }

                return item;
              })
            ),

            // √âtoiles : tableau plat pour √©conomiser de l'espace
            st: currentSubStars.flat(),

            // Version du format (pour compatibilit√© future)
            v: 1,
          };

          console.log("Saving team data to server:", teamData);

          // Envoyer au serveur
          const response = await fetch("/api/teams", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(teamData),
          });

          const result = await response.json();

          if (result.success) {
            const teamId = result.id;

            // Cr√©er l'URL courte
            const titleSlug = slugify(currentTeamTitle);
            const teamURL = `${window.location.origin}${window.location.pathname}team/${teamId}/${titleSlug}`;

            console.log("Team saved with ID:", teamId);
            console.log("Generated URL:", teamURL);

            // Afficher le lien
            document.getElementById("team-link-display").value = teamURL;

            // Copier dans le clipboard
            navigator.clipboard
              .writeText(teamURL)
              .then(() => {
                alert(
                  `‚úÖ Team saved!\n\nShort link copied to clipboard (${teamURL.length} characters):\n${teamURL}`
                );
              })
              .catch(() => {
                prompt("Copy this short link to share your team:", teamURL);
              });
          } else {
            throw new Error(result.error || "Failed to save team");
          }
        } catch (error) {
          console.error("Error saving team:", error);
          alert("‚ùå Failed to save team: " + error.message);
        } finally {
          // Restaurer le bouton
          saveBtn.textContent = originalText;
          saveBtn.disabled = false;
        }
      }

      async function loadTeamFromURL() {
        const path = window.location.pathname;
        const teamMatch = path.match(/\/team\/([^\/]+)\/([^\/]+)/);

        if (teamMatch) {
          const teamId = teamMatch[1];
          const titleSlug = teamMatch[2];

          console.log("Loading team from server ID:", teamId);

          try {
            // Charger depuis le serveur
            const response = await fetch(`/api/teams/${teamId}`);
            const result = await response.json();

            if (result.success) {
              const teamData = result.data;
              console.log("Team data loaded from server:", teamData);
              loadTeamDataFromServer(teamData);
            } else {
              throw new Error(result.error || "Team not found");
            }
          } catch (error) {
            console.error("Error loading team from server:", error);
            alert(
              "‚ùå Team not found! The link may be invalid or the server may be down."
            );
          }
        }

        return true; // Indiquer que le chargement est termin√©
      }

      function loadTeamDataFromServer(teamData) {
        // R√©initialiser l'√©quipe actuelle
        currentTeam = Array(MAX_TEAM_SLOTS).fill(null);
        currentSubSlots = Array(MAX_TEAM_SLOTS)
          .fill(null)
          .map(() => Array(4).fill(null));
        currentSubStars = Array(MAX_TEAM_SLOTS)
          .fill(null)
          .map(() => Array(4).fill(0));

        // Charger le titre
        if (teamData.t) {
          currentTeamTitle = teamData.t;
          document.getElementById("team-title-display").textContent =
            teamData.t;
        }

        // Charger les h√©ros
        if (teamData.h) {
          teamData.h.forEach((heroId, index) => {
            if (heroId) {
              const hero = allHeroes.find((h) => h.id === heroId);
              if (hero) {
                currentTeam[index] = hero;
                console.log(`Loaded hero: ${hero.name} at slot ${index}`);
              } else {
                console.warn(`Hero not found: ${heroId}`);
              }
            }
          });
        }

        // Charger les sous-slots optimis√©s
        if (teamData.s) {
          teamData.s.forEach((slot, slotIndex) => {
            slot.forEach((optimizedItem, subIndex) => {
              if (!optimizedItem) {
                currentSubSlots[slotIndex][subIndex] = null;
                return;
              }

              const hero = currentTeam[slotIndex];

              if (optimizedItem === "uw") {
                // UW
                if (hero) {
                  currentSubSlots[slotIndex][
                    subIndex
                  ] = `/kingsraid-data/assets/heroes/${hero.name}/uw.png`;
                }
              } else if (optimizedItem.startsWith("ut")) {
                // UT
                const utNum = optimizedItem.replace("ut", "");
                if (hero) {
                  currentSubSlots[slotIndex][
                    subIndex
                  ] = `/kingsraid-data/assets/heroes/${hero.name}/ut/${utNum}.png`;
                }
              } else if (
                typeof optimizedItem === "string" &&
                optimizedItem.includes(",")
              ) {
                // Perks (string avec virgules)
                currentSubSlots[slotIndex][subIndex] = optimizedItem
                  .split(",")
                  .map(Number);
              } else {
                // Artifact (nom simple)
                currentSubSlots[slotIndex][
                  subIndex
                ] = `/kingsraid-data/assets/artifacts/${optimizedItem}.png`;
              }
            });
          });
        }

        // Charger les √©toiles (tableau plat ‚Üí structure 2D)
        if (teamData.st && Array.isArray(teamData.st)) {
          for (let i = 0; i < MAX_TEAM_SLOTS; i++) {
            for (let j = 0; j < 4; j++) {
              const flatIndex = i * 4 + j;
              if (teamData.st[flatIndex] !== undefined) {
                currentSubStars[i][j] = teamData.st[flatIndex];
              }
            }
          }
        }

        // Mettre √† jour l'affichage
        updateTeamDisplay();
        refreshHeroesDisplay();

        console.log("‚úÖ Team loaded successfully from server!");
      }

      function slugify(text) {
        return text
          .toString()
          .toLowerCase()
          .replace(/\s+/g, "-") // Remplacer les espaces par des tirets
          .replace(/[^\w\-]+/g, "") // Supprimer les caract√®res non alphanum√©riques
          .replace(/\-\-+/g, "-") // Remplacer les tirets multiples par un seul
          .replace(/^-+/, "") // Supprimer les tirets du d√©but
          .replace(/-+$/, "") // Supprimer les tirets de la fin
          .substring(0, 30); // Limiter la longueur
      }

      // ========== FONCTIONS EXISTANTES ==========

      function handleSubSlotClick(teamSlotIndex, subSlotIndex) {
        const hero = currentTeam[teamSlotIndex];
        if (!hero) {
          alert("Veuillez d'abord ajouter un h√©ros dans ce slot!");
          return;
        }

        // Slot 0: UW (uw.png)
        if (subSlotIndex === 0) {
          openUWModal(teamSlotIndex, subSlotIndex, hero.name);
        }
        // Slot 1: UT (choix parmi 1.png, 2.png, 3.png, 4.png)
        else if (subSlotIndex === 1) {
          openUTModal(teamSlotIndex, subSlotIndex, hero.name);
        }
        // Slot 2: Artifact
        else if (subSlotIndex === 2) {
          if (allArtifacts.length === 0) {
            alert("Artifacts are still loading, please wait...");
            loadArtifacts().then(() => {
              openArtifactModal(teamSlotIndex, subSlotIndex);
            });
          } else {
            openArtifactModal(teamSlotIndex, subSlotIndex);
          }
        }
        // Slot 3: Perks
        else if (subSlotIndex === 3) {
          openPerkModal(teamSlotIndex, subSlotIndex);
        }
      }

      function openUWModal(teamSlotIndex, subSlotIndex, heroName) {
        currentModalData = {
          teamSlotIndex,
          subSlotIndex,
          heroName,
          selectedStars: currentSubStars[teamSlotIndex][subSlotIndex] || 0,
          selectedOption: currentSubSlots[teamSlotIndex][subSlotIndex]
            ? "uw"
            : "empty",
        };

        const modal = document.getElementById("uw-modal");
        const optionsContainer = document.getElementById("uw-options");
        const starsContainer = document.getElementById("uw-stars");

        // Cr√©er les options UW
        optionsContainer.innerHTML = "";

        // Option UW
        const uwOption = document.createElement("div");
        uwOption.className = `uw-option ${
          currentModalData.selectedOption === "uw" ? "selected" : ""
        }`;
        const uwPath = `/kingsraid-data/assets/heroes/${heroName}/uw.png`;
        uwOption.innerHTML = `<img src="${uwPath}" alt="UW" class="w-full h-full object-cover rounded">`;
        uwOption.onclick = () => selectUWOption("uw");
        optionsContainer.appendChild(uwOption);

        // Option vide
        const emptyOption = document.createElement("div");
        emptyOption.className = `uw-option ${
          currentModalData.selectedOption === "empty" ? "selected" : ""
        }`;
        emptyOption.innerHTML =
          '<div class="w-full h-full flex items-center justify-center text-gray-400 text-sm">Empty</div>';
        emptyOption.onclick = () => selectUWOption("empty");
        optionsContainer.appendChild(emptyOption);

        // Cr√©er les √©toiles
        createStars(starsContainer, "uw", currentModalData.selectedStars);

        modal.style.display = "flex";
      }

      function openUTModal(teamSlotIndex, subSlotIndex, heroName) {
        currentModalData = {
          teamSlotIndex,
          subSlotIndex,
          heroName,
          selectedUT: currentSubSlots[teamSlotIndex][subSlotIndex]
            ? parseInt(
                currentSubSlots[teamSlotIndex][subSlotIndex]
                  .split("/ut/")[1]
                  .split(".")[0]
              )
            : 0,
          selectedStars: currentSubStars[teamSlotIndex][subSlotIndex] || 0,
        };

        const modal = document.getElementById("ut-modal");
        const optionsContainer = document.getElementById("ut-options");
        const emptyContainer = document.getElementById("ut-empty-option");
        const starsContainer = document.getElementById("ut-stars");

        optionsContainer.innerHTML = "";
        emptyContainer.innerHTML = "";

        // Cr√©er les 4 options UT
        for (let i = 1; i <= 4; i++) {
          const option = document.createElement("div");
          option.className = `ut-option ${
            currentModalData.selectedUT === i ? "selected" : ""
          }`;
          const utPath = `/kingsraid-data/assets/heroes/${heroName}/ut/${i}.png`;
          option.innerHTML = `<img src="${utPath}" alt="UT ${i}" class="w-full h-full object-cover rounded">`;
          option.onclick = () => selectUTOption(i);
          optionsContainer.appendChild(option);
        }

        // Option vide (en dessous)
        const emptyOption = document.createElement("div");
        emptyOption.className = `ut-option ${
          currentModalData.selectedUT === 0 ? "selected" : ""
        }`;
        emptyOption.innerHTML =
          '<div class="w-full h-full flex items-center justify-center text-gray-400 text-sm">Empty</div>';
        emptyOption.onclick = () => selectUTOption(0);
        emptyContainer.appendChild(emptyOption);

        // Cr√©er les √©toiles
        createStars(starsContainer, "ut", currentModalData.selectedStars);

        modal.style.display = "flex";
      }

      function openArtifactModal(teamSlotIndex, subSlotIndex) {
        currentModalData = {
          teamSlotIndex,
          subSlotIndex,
          selectedArtifact: currentSubSlots[teamSlotIndex][subSlotIndex]
            ? currentSubSlots[teamSlotIndex][subSlotIndex]
                .split("/artifacts/")[1]
                .split(".")[0]
            : null,
          selectedStars: currentSubStars[teamSlotIndex][subSlotIndex] || 0,
          allArtifacts: [...allArtifacts], // Copie pour la recherche
        };

        const modal = document.getElementById("artifact-modal");
        const optionsContainer = document.getElementById("artifact-options");
        const emptyContainer = document.getElementById("artifact-empty-option");
        const starsContainer = document.getElementById("artifact-stars");
        const searchInput = document.getElementById("artifact-search");

        console.log(
          `üîß Ouverture modal artefact pour slot ${teamSlotIndex}, sous-slot ${subSlotIndex}`
        );
        console.log(`üé® Affichage de ${allArtifacts.length} artefacts`);

        // R√©initialiser la recherche
        searchInput.value = "";

        // Configurer la recherche
        searchInput.oninput = (e) => {
          filterArtifacts(e.target.value.toLowerCase());
        };

        // Afficher tous les artefacts initialement
        displayArtifacts(allArtifacts, optionsContainer);

        // Option vide
        emptyContainer.innerHTML = "";
        const emptyOption = document.createElement("div");
        emptyOption.className = `artifact-option ${
          currentModalData.selectedArtifact === null ? "selected" : ""
        }`;
        emptyOption.innerHTML =
          '<div class="w-full h-full flex items-center justify-center text-gray-400 text-sm">Empty</div>';
        emptyOption.onclick = () => selectArtifactOption(null);
        emptyContainer.appendChild(emptyOption);

        // Cr√©er les √©toiles
        createStars(starsContainer, "artifact", currentModalData.selectedStars);

        modal.style.display = "flex";
      }

      function openPerkModal(teamSlotIndex, subSlotIndex) {
        currentModalData = {
          teamSlotIndex,
          subSlotIndex,
          selectedPerks: currentSubSlots[teamSlotIndex][subSlotIndex] || [],
          maxPoints: 95,
          usedPoints: 0,
        };

        const modal = document.getElementById("perk-modal");
        const optionsContainer = document.getElementById("perk-options");
        const pointsUsedElement = document.getElementById("perk-points-used");
        const pointsDisplay = document.getElementById("perk-points-display");

        // R√©initialiser
        optionsContainer.innerHTML = "";
        currentModalData.usedPoints = 0;

        // Cr√©er la structure des perks
        const perkLayout = [
          { count: 5, cost: 10 }, // Row 1: 5 perks, cost 10
          { count: 5, cost: 15 }, // Row 2: 5 perks, cost 15
          { count: 4, cost: 15 }, // Row 3: 4 perks, cost 15
          { count: 4, cost: 15 }, // Row 4: 4 perks, cost 15
          { count: 2, cost: 15 }, // Row 5: 2 perks, cost 15
        ];

        // Cr√©er les rows de perks
        perkLayout.forEach((row, rowIndex) => {
          const rowElement = document.createElement("div");
          rowElement.className = "perk-row";

          for (let i = 0; i < row.count; i++) {
            const perkIndex = rowIndex * 10 + i; // Index unique pour chaque perk
            const perkOption = document.createElement("div");
            perkOption.className = "perk-option";
            perkOption.textContent = row.cost;
            perkOption.dataset.cost = row.cost;
            perkOption.dataset.index = perkIndex;

            // V√©rifier si ce perk est d√©j√† s√©lectionn√©
            if (currentModalData.selectedPerks.includes(perkIndex)) {
              perkOption.classList.add("selected");
              currentModalData.usedPoints += row.cost;
            }

            perkOption.onclick = () =>
              togglePerkSelection(perkOption, row.cost, perkIndex);
            rowElement.appendChild(perkOption);
          }

          optionsContainer.appendChild(rowElement);
        });

        // Mettre √† jour l'affichage des points
        updatePerkPointsDisplay();

        modal.style.display = "flex";
      }

      function togglePerkSelection(perkElement, cost, perkIndex) {
        const isSelected = perkElement.classList.contains("selected");
        const newPoints = isSelected
          ? currentModalData.usedPoints - cost
          : currentModalData.usedPoints + cost;

        // V√©rifier si on d√©passe la limite
        if (newPoints > currentModalData.maxPoints && !isSelected) {
          alert(
            `Cannot select this perk! You would exceed the ${currentModalData.maxPoints} point limit.`
          );
          return;
        }

        // Basculer la s√©lection
        if (isSelected) {
          perkElement.classList.remove("selected");
          currentModalData.usedPoints -= cost;
          // Retirer le perk du tableau selectedPerks
          const index = currentModalData.selectedPerks.indexOf(perkIndex);
          if (index > -1) {
            currentModalData.selectedPerks.splice(index, 1);
          }
        } else {
          perkElement.classList.add("selected");
          currentModalData.usedPoints += cost;
          currentModalData.selectedPerks.push(perkIndex);
        }

        updatePerkPointsDisplay();
      }

      function updatePerkPointsDisplay() {
        const pointsUsedElement = document.getElementById("perk-points-used");
        const pointsDisplay = document.getElementById("perk-points-display");

        pointsUsedElement.textContent = currentModalData.usedPoints;

        // Changer la couleur si on d√©passe la limite
        if (currentModalData.usedPoints > currentModalData.maxPoints) {
          pointsDisplay.classList.add("over-limit");
        } else {
          pointsDisplay.classList.remove("over-limit");
        }
      }

      function confirmPerkSelection() {
        const { teamSlotIndex, subSlotIndex, selectedPerks } = currentModalData;

        // Stocker les perks s√©lectionn√©s
        currentSubSlots[teamSlotIndex][subSlotIndex] = selectedPerks;

        // Mettre √† jour l'affichage du sous-slot
        updatePerkSubSlotDisplay(teamSlotIndex, subSlotIndex, selectedPerks);

        // Mettre √† jour la preview des perks
        updatePerkPreview(teamSlotIndex, selectedPerks);

        closeModal("perk-modal");
      }

      function updatePerkSubSlotDisplay(
        teamSlotIndex,
        subSlotIndex,
        selectedPerks
      ) {
        const slotContainers = document.getElementById("team-slots").children;
        const slotContainer = slotContainers[teamSlotIndex];
        const subSlotsContainer = slotContainer.children[1];
        const subSlot = subSlotsContainer.children[subSlotIndex];

        if (selectedPerks && selectedPerks.length > 0) {
          subSlot.className =
            "sub-slot w-[48px] h-[48px] rounded flex items-center justify-center cursor-pointer perk-slot-active";
          subSlot.innerHTML = `
            <div class="w-full h-full flex items-center justify-center text-black text-xs font-bold">
              Perks
            </div>
          `;
        } else {
          subSlot.className =
            "sub-slot w-[48px] h-[48px] rounded flex items-center justify-center cursor-pointer empty";
          subSlot.innerHTML = '<span class="text-gray-400 text-xs">+</span>';
        }
      }

      function updatePerkPreview(teamSlotIndex, selectedPerks) {
        const previewContainer = document.getElementById(
          `perk-preview-${teamSlotIndex}`
        );
        previewContainer.innerHTML = "";

        if (!selectedPerks || selectedPerks.length === 0) {
          return;
        }

        // Structure des perks pour la preview
        const perkLayout = [5, 5, 4, 4, 2];

        perkLayout.forEach((perkCount, rowIndex) => {
          const rowElement = document.createElement("div");
          rowElement.className = "perk-preview-row";

          for (let i = 0; i < perkCount; i++) {
            const perkIndex = rowIndex * 10 + i;
            const perkPreview = document.createElement("div");
            perkPreview.className = "perk-preview-option";

            // Marquer comme s√©lectionn√© si pr√©sent dans selectedPerks
            if (selectedPerks.includes(perkIndex)) {
              perkPreview.classList.add("selected");
            }

            rowElement.appendChild(perkPreview);
          }

          previewContainer.appendChild(rowElement);
        });
      }

      function displayArtifacts(artifacts, container) {
        container.innerHTML = "";

        artifacts.forEach((artifactName) => {
          const option = document.createElement("div");
          option.className = `artifact-option ${
            currentModalData.selectedArtifact === artifactName ? "selected" : ""
          }`;

          const artifactPath = `/kingsraid-data/assets/artifacts/${artifactName}.png`;

          option.innerHTML = `
            <img src="${artifactPath}" alt="${artifactName}" 
                 class="w-full h-full object-cover rounded"
                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'">
            <div class="absolute inset-0 flex items-center justify-center text-gray-400 text-xs hidden bg-gray-800 rounded p-1 text-center">
              ${artifactName}
            </div>
          `;

          option.onclick = () => selectArtifactOption(artifactName);
          container.appendChild(option);
        });
      }

      function filterArtifacts(searchTerm) {
        const optionsContainer = document.getElementById("artifact-options");

        if (!searchTerm) {
          // Afficher tous les artefacts si la recherche est vide
          displayArtifacts(allArtifacts, optionsContainer);
          return;
        }

        // Filtrer les artefacts par nom
        const filteredArtifacts = allArtifacts.filter((artifactName) =>
          artifactName.toLowerCase().includes(searchTerm)
        );

        displayArtifacts(filteredArtifacts, optionsContainer);
      }

      function selectUWOption(option) {
        document.querySelectorAll(".uw-option").forEach((opt) => {
          opt.classList.remove("selected");
        });
        event.target.closest(".uw-option").classList.add("selected");
        currentModalData.selectedOption = option;
      }

      function selectUTOption(utNumber) {
        document.querySelectorAll(".ut-option").forEach((option) => {
          option.classList.remove("selected");
        });
        event.target.closest(".ut-option").classList.add("selected");
        currentModalData.selectedUT = utNumber;
      }

      function selectArtifactOption(artifactName) {
        // Retirer la s√©lection pr√©c√©dente de tous les artefacts
        document.querySelectorAll(".artifact-option").forEach((option) => {
          option.classList.remove("selected");
        });

        // Ajouter la s√©lection actuelle
        const selectedElement = event.target.closest(".artifact-option");
        if (selectedElement) {
          selectedElement.classList.add("selected");
        }

        // Stocker temporairement le nom de l'artefact s√©lectionn√© (null pour vide)
        currentModalData.selectedArtifact = artifactName;
      }

      function createStars(container, type, currentStars) {
        container.innerHTML = "";

        // Ajouter l'option 0 √©toiles (X) √† gauche
        const zeroStar = document.createElement("span");
        zeroStar.className = "star";
        zeroStar.innerHTML = "√ó";
        zeroStar.style.color = "#EF4444";
        zeroStar.onclick = () => selectStars(0, type);
        container.appendChild(zeroStar);

        // Ajouter les 5 √©toiles
        for (let i = 1; i <= 5; i++) {
          const star = document.createElement("span");
          star.className = `star ${i <= currentStars ? "filled" : ""}`;
          star.innerHTML = i <= currentStars ? "‚òÖ" : "‚òÜ";
          star.dataset.value = i;

          star.addEventListener("mouseover", () =>
            showHoverPreview(i, type, currentStars)
          );
          star.addEventListener("mouseout", () =>
            clearHoverPreview(type, currentStars)
          );
          star.addEventListener("click", () => selectStars(i, type));

          container.appendChild(star);
        }
      }

      function showHoverPreview(hoveredStar, type, currentStars) {
        const starsContainer = document.getElementById(`${type}-stars`);
        const stars = starsContainer.querySelectorAll(".star");

        stars.forEach((star, index) => {
          if (index > 0) {
            const starValue = parseInt(star.dataset.value);
            if (starValue > currentStars && starValue <= hoveredStar) {
              star.classList.add("hover-preview");
            } else {
              star.classList.remove("hover-preview");
            }
          }
        });
      }

      function clearHoverPreview(type, currentStars) {
        const starsContainer = document.getElementById(`${type}-stars`);
        const stars = starsContainer.querySelectorAll(".star");

        stars.forEach((star, index) => {
          if (index > 0) {
            star.classList.remove("hover-preview");
          }
        });
      }

      function selectStars(starCount, type) {
        currentModalData.selectedStars = starCount;

        const starsContainer = document.getElementById(`${type}-stars`);
        const stars = starsContainer.querySelectorAll(".star");

        stars.forEach((star, index) => {
          if (index > 0) {
            if (index <= starCount) {
              star.innerHTML = "‚òÖ";
              star.classList.add("filled");
              star.classList.remove("hover-preview");
            } else {
              star.innerHTML = "‚òÜ";
              star.classList.remove("filled", "hover-preview");
            }
          }
        });
      }

      function confirmUWSelection() {
        if (!currentModalData) return;

        const {
          teamSlotIndex,
          subSlotIndex,
          heroName,
          selectedOption,
          selectedStars,
        } = currentModalData;

        if (selectedOption === "empty") {
          currentSubSlots[teamSlotIndex][subSlotIndex] = null;
          currentSubStars[teamSlotIndex][subSlotIndex] = 0;
          removeSubItem(teamSlotIndex, subSlotIndex);
        } else {
          const uwPath = `/kingsraid-data/assets/heroes/${heroName}/uw.png`;
          currentSubSlots[teamSlotIndex][subSlotIndex] = uwPath;
          currentSubStars[teamSlotIndex][subSlotIndex] = selectedStars;
          updateSubSlotDisplay(
            teamSlotIndex,
            subSlotIndex,
            uwPath,
            selectedStars
          );
        }

        closeModal("uw-modal");
      }

      function confirmUTSelection() {
        if (!currentModalData || currentModalData.selectedUT === null) {
          alert("Veuillez s√©lectionner une option UT!");
          return;
        }

        const {
          teamSlotIndex,
          subSlotIndex,
          heroName,
          selectedUT,
          selectedStars,
        } = currentModalData;

        if (selectedUT === 0) {
          currentSubSlots[teamSlotIndex][subSlotIndex] = null;
          currentSubStars[teamSlotIndex][subSlotIndex] = 0;
          removeSubItem(teamSlotIndex, subSlotIndex);
        } else {
          const utPath = `/kingsraid-data/assets/heroes/${heroName}/ut/${selectedUT}.png`;
          currentSubSlots[teamSlotIndex][subSlotIndex] = utPath;
          currentSubStars[teamSlotIndex][subSlotIndex] = selectedStars;
          updateSubSlotDisplay(
            teamSlotIndex,
            subSlotIndex,
            utPath,
            selectedStars
          );
        }

        closeModal("ut-modal");
      }

      function confirmArtifactSelection() {
        if (
          !currentModalData ||
          currentModalData.selectedArtifact === undefined
        ) {
          alert("Please select an artifact option!");
          return;
        }

        const { teamSlotIndex, subSlotIndex, selectedArtifact, selectedStars } =
          currentModalData;

        if (selectedArtifact === null) {
          currentSubSlots[teamSlotIndex][subSlotIndex] = null;
          currentSubStars[teamSlotIndex][subSlotIndex] = 0;
          removeSubItem(teamSlotIndex, subSlotIndex);
        } else {
          const artifactPath = `/kingsraid-data/assets/artifacts/${selectedArtifact}.png`;
          currentSubSlots[teamSlotIndex][subSlotIndex] = artifactPath;
          currentSubStars[teamSlotIndex][subSlotIndex] = selectedStars;
          updateSubSlotDisplay(
            teamSlotIndex,
            subSlotIndex,
            artifactPath,
            selectedStars
          );
        }

        closeModal("artifact-modal");
      }

      function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        modal.style.display = "none";
        currentModalData = null;
      }

      function updateSubSlotDisplay(
        teamSlotIndex,
        subSlotIndex,
        imagePath,
        stars
      ) {
        const slotContainers = document.getElementById("team-slots").children;
        const slotContainer = slotContainers[teamSlotIndex];
        const subSlotsContainer = slotContainer.children[1];
        const subSlot = subSlotsContainer.children[subSlotIndex];

        const starsDisplay =
          stars > 0 ? `<div class="stars-text">${stars}‚òÖ</div>` : "";

        subSlot.className =
          "sub-slot w-[48px] h-[48px] rounded flex items-center justify-center cursor-pointer";
        subSlot.innerHTML = `
          <img src="${imagePath}" alt="Sub item" class="sub-slot-image">
          ${starsDisplay}
        `;
      }

      function removeSubItem(teamSlotIndex, subSlotIndex) {
        event.stopPropagation();
        currentSubSlots[teamSlotIndex][subSlotIndex] = null;
        currentSubStars[teamSlotIndex][subSlotIndex] = 0;

        const slotContainers = document.getElementById("team-slots").children;
        const slotContainer = slotContainers[teamSlotIndex];
        const subSlotsContainer = slotContainer.children[1];
        const subSlot = subSlotsContainer.children[subSlotIndex];

        subSlot.className =
          "sub-slot w-[48px] h-[48px] rounded flex items-center justify-center cursor-pointer empty";
        subSlot.innerHTML = '<span class="text-gray-400 text-xs">+</span>';
      }

      async function loadHeroes(sortType = "name") {
        try {
          console.log(`üîÑ Chargement des h√©ros avec tri: ${sortType}`);
          const response = await fetch(`/api/heroes?sort=${sortType}`);

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          console.log("üìä Donn√©es re√ßues:", data);

          allHeroes = data.heroes || [];
          currentSort = sortType;

          console.log(
            `‚úÖ ${allHeroes.length} h√©ros charg√©s avec tri: ${sortType}`
          );

          displayHeroes(allHeroes);
          updateHeroCount(allHeroes.length);

          document.getElementById("sort-filter").value = sortType;

          return allHeroes; // Retourner les h√©ros charg√©s
        } catch (error) {
          console.error("‚ùå Error loading heroes:", error);
          allHeroes = [];
          displayHeroes([]);
          updateHeroCount(0);
          throw error; // Propager l'erreur
        }
      }

      function displayHeroes(heroes) {
        const heroesGrid = document.getElementById("heroes-grid");

        if (!heroes || !Array.isArray(heroes)) {
          console.error("‚ùå displayHeroes: heroes n'est pas un array", heroes);
          heroes = [];
        }

        heroesGrid.innerHTML = "";

        console.log(`üé® Affichage de ${heroes.length} h√©ros`);

        heroes.forEach((hero) => {
          const heroCard = document.createElement("div");

          const isInTeam = currentTeam.some(
            (slot) => slot && slot.id === hero.id
          );

          heroCard.className = `hero-card rounded cursor-pointer ${
            isInTeam ? "in-team" : ""
          }`;

          const classIconPath = getClassIconPath(hero.role);

          const classIconHTML = classIconPath
            ? `<img src="${classIconPath}" alt="${hero.role}" class="class-icon">`
            : "";

          heroCard.innerHTML = `
            <img src="${hero.image}" alt="${hero.name}" class="hero-image rounded">
            <div class="hero-name">${hero.name}</div>
            ${classIconHTML}
          `;

          heroCard.onclick = () => {
            if (isInTeam) {
              removeHeroFromTeam(hero.id);
            } else {
              addHeroToTeam(hero);
            }
          };

          heroesGrid.appendChild(heroCard);
        });
      }

      function getClassIconPath(className) {
        const classMap = {
          Knight: "/kingsraid-data/assets/classes_hd/knight.png",
          Warrior: "/kingsraid-data/assets/classes_hd/warrior.png",
          Archer: "/kingsraid-data/assets/classes_hd/archer.png",
          Mechanic: "/kingsraid-data/assets/classes_hd/mechanic.png",
          Assassin: "/kingsraid-data/assets/classes_hd/assassin.png",
          Wizard: "/kingsraid-data/assets/classes_hd/wizard.png",
          Priest: "/kingsraid-data/assets/classes_hd/priest.png",
        };

        return classMap[className] || null;
      }

      function setupFilters() {
        const roleFilter = document.getElementById("role-filter");
        const searchInput = document.getElementById("search-input");

        roleFilter.addEventListener("change", filterHeroes);
        searchInput.addEventListener("input", filterHeroes);

        console.log("‚úÖ Filtres r√¥le et recherche attach√©s");
      }

      function filterHeroes() {
        const roleFilter = document.getElementById("role-filter").value;
        const searchTerm = document
          .getElementById("search-input")
          .value.toLowerCase();

        let filteredHeroes = allHeroes;

        if (roleFilter !== "all") {
          filteredHeroes = filteredHeroes.filter(
            (hero) => hero.role === roleFilter
          );
        }

        if (searchTerm) {
          filteredHeroes = filteredHeroes.filter((hero) =>
            hero.name.toLowerCase().includes(searchTerm)
          );
        }

        console.log(
          `üîç Filtrage: ${filteredHeroes.length} h√©ros apr√®s filtres`
        );
        displayHeroes(filteredHeroes);
        updateHeroCount(filteredHeroes.length);
      }

      function updateHeroCount(count) {
        document.getElementById("hero-count").textContent = `${count} heroes`;
      }

      function addHeroToTeam(hero) {
        const emptySlotIndex = currentTeam.findIndex((slot) => slot === null);
        if (emptySlotIndex !== -1) {
          if (currentTeam.some((slot) => slot && slot.id === hero.id)) {
            alert("This hero is already in your team!");
            return;
          }

          currentTeam[emptySlotIndex] = hero;
          updateTeamDisplay();
          refreshHeroesDisplay();
        } else {
          alert("No empty slots available! Remove a hero first.");
        }
      }

      function removeHeroFromTeam(heroId) {
        const heroIndex = currentTeam.findIndex(
          (slot) => slot && slot.id === heroId
        );
        if (heroIndex !== -1) {
          const hero = currentTeam[heroIndex];

          const hasSubItems = currentSubSlots[heroIndex].some(
            (slot) => slot !== null
          );

          if (hasSubItems) {
            pendingRemoveHeroId = heroId;
            document.getElementById(
              "remove-hero-message"
            ).textContent = `Are you sure you want to remove "${hero.name}" from the team?`;
            document.getElementById("remove-hero-modal").style.display = "flex";
          } else {
            performHeroRemoval(heroIndex);
          }
        }
      }

      function performHeroRemoval(heroIndex) {
        currentSubSlots[heroIndex] = Array(4).fill(null);
        currentSubStars[heroIndex] = Array(4).fill(0);
        currentTeam[heroIndex] = null;
        updateTeamDisplay();
        refreshHeroesDisplay();
      }

      function confirmRemoveHero() {
        if (pendingRemoveHeroId) {
          const heroIndex = currentTeam.findIndex(
            (slot) => slot && slot.id === pendingRemoveHeroId
          );

          if (heroIndex !== -1) {
            performHeroRemoval(heroIndex);
          }

          pendingRemoveHeroId = null;
          closeModal("remove-hero-modal");
        }
      }

      function updateTeamDisplay() {
        const slotContainers = document.getElementById("team-slots").children;

        currentTeam.forEach((hero, index) => {
          const slotContainer = slotContainers[index];
          const mainSlot = slotContainer.children[0];
          const subSlotsContainer = slotContainer.children[1];
          const perkPreviewContainer = document.getElementById(
            `perk-preview-${index}`
          );

          if (hero) {
            const classIconPath = getClassIconPath(hero.role);
            const classIconHTML = classIconPath
              ? `<img src="${classIconPath}" alt="${hero.role}" class="class-icon">`
              : "";

            mainSlot.className =
              "character-slot w-[100px] h-[100px] rounded flex items-center justify-center cursor-pointer";
            mainSlot.innerHTML = `
              <img src="${hero.image}" alt="${hero.name}" class="w-full h-full rounded object-cover">
              <div class="team-hero-name">${hero.name}</div>
              ${classIconHTML}
              <div class="remove-btn" onclick="removeHeroFromTeam('${hero.id}')">
                <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="white" stroke-width="2">
                  <path d="M3 3L9 9M9 3L3 9"/>
                </svg>
              </div>
            `;

            for (let j = 0; j < 4; j++) {
              const subSlot = subSlotsContainer.children[j];
              const subItem = currentSubSlots[index][j];
              const subStars = currentSubStars[index][j];

              if (subItem) {
                if (j === 3 && Array.isArray(subItem)) {
                  // C'est un slot de perks
                  updatePerkSubSlotDisplay(index, j, subItem);
                  updatePerkPreview(index, subItem);
                } else {
                  const starsDisplay =
                    subStars > 0
                      ? `<div class="stars-text">${subStars}‚òÖ</div>`
                      : "";

                  subSlot.className =
                    "sub-slot w-[48px] h-[48px] rounded flex items-center justify-center cursor-pointer";
                  subSlot.innerHTML = `
                    <img src="${subItem}" alt="Sub item" class="sub-slot-image">
                    ${starsDisplay}
                  `;
                }
              } else {
                subSlot.className =
                  "sub-slot w-[48px] h-[48px] rounded flex items-center justify-center cursor-pointer empty";
                subSlot.innerHTML =
                  '<span class="text-gray-400 text-xs">+</span>';
              }
            }
          } else {
            mainSlot.className =
              "character-slot w-[100px] h-[100px] rounded flex items-center justify-center cursor-pointer empty";
            mainSlot.innerHTML = '<span class="text-gray-400 text-lg">+</span>';

            for (let j = 0; j < 4; j++) {
              const subSlot = subSlotsContainer.children[j];
              subSlot.className =
                "sub-slot w-[48px] h-[48px] rounded flex items-center justify-center cursor-pointer empty";
              subSlot.innerHTML =
                '<span class="text-gray-400 text-xs">+</span>';
            }

            // Vider la preview des perks
            perkPreviewContainer.innerHTML = "";
          }
        });

        const currentSize = currentTeam.filter((hero) => hero !== null).length;
        document.getElementById("current-team-size").textContent = currentSize;
        document.getElementById("max-team-size").textContent = MAX_TEAM_SLOTS;
      }

      function refreshHeroesDisplay() {
        const roleFilter = document.getElementById("role-filter").value;
        const searchTerm = document
          .getElementById("search-input")
          .value.toLowerCase();

        let filteredHeroes = allHeroes;

        if (roleFilter !== "all") {
          filteredHeroes = filteredHeroes.filter(
            (hero) => hero.role === roleFilter
          );
        }

        if (searchTerm) {
          filteredHeroes = filteredHeroes.filter((hero) =>
            hero.name.toLowerCase().includes(searchTerm)
          );
        }

        displayHeroes(filteredHeroes);
      }
    </script>
  </body>
</html>
